namespace PropertyNotify;

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public class Generator : IIncrementalGenerator
{
    const string attribute_namespace = "PropertyNotify";
    const string attribute_name = "NotifyAttribute";
    const string notify_attribute_source = "namespace " + attribute_namespace + @";

[System.AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
public sealed class " + attribute_name + @"(string method_name = ""OnPropertyChanged"", bool pass_changed_name = false, bool pass_old_value = false) : System.Attribute
{
    public string MethodName { get; } = method_name;
    public bool PassChangedName { get; } = pass_changed_name;
    public bool PassOldValue { get; } = pass_old_value;
}";
    const string default_method_name = "OnPropertyChanged";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{attribute_name}.Generated.cs", SourceText.From(notify_attribute_source, Encoding.UTF8)));

        var propertyDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName($"{attribute_namespace}.{attribute_name}",
                IsValidTarget,
                GetSemanticTargetForGeneration);

        var combined = context.CompilationProvider.Combine(propertyDeclarations.Collect());

        context.RegisterSourceOutput(combined, static (spc, source) => Execute(source.Right, spc));
    }

    private static bool IsValidTarget(SyntaxNode context, CancellationToken _)
    {
        if (context is not PropertyDeclarationSyntax { AttributeLists.Count: > 0 } prop)
            return false;

        var valid = prop.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        return valid;
    }

    private static PropertyInfo GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        var attribute = context.Attributes.First();
        var symbol = context.TargetSymbol as IPropertySymbol;
        var method_name = default_method_name;
        var pass_changed_name = false;
        var pass_old_value = false;

        var init_args = attribute.ConstructorArguments;
        if (init_args.Length > 0)
        {
            var arg_value = init_args[0].Value?.ToString();
            if (!string.IsNullOrEmpty(arg_value))
                method_name = arg_value;
            if (init_args.Length > 1)
                pass_changed_name = (bool)init_args[1].Value;
            if (init_args.Length > 2)
                pass_old_value = (bool)init_args[2].Value;
        }

        var containing_type = context.TargetSymbol.ContainingType;
        var containing_ns = containing_type.ContainingNamespace?.ToDisplayString();
        if (containing_ns == "<global namespace>")
            containing_ns = null;

        return new PropertyInfo
        {
            TypeName = symbol.Type.ToDisplayString(),
            PropertyName = symbol.Name,
            MethodName = method_name,
            PassChangedName = pass_changed_name,
            PassOldValue = pass_old_value,
            ClassName = containing_type.Name,
            Namespace = containing_ns,
            IsPublic = symbol.DeclaredAccessibility == Accessibility.Public,
            FullTypeName = containing_type.ToDisplayString()
        };
    }

    private static void Execute(ImmutableArray<PropertyInfo> properties, SourceProductionContext context)
    {
        if (properties.IsDefaultOrEmpty)
            return;

        var by_class = properties.GroupBy(p => p.FullTypeName);

        foreach (var class_props in by_class)
        {
            var class_name = class_props.First().ClassName;
            var namespace_name = class_props.First().Namespace;
            var props = class_props.ToList();

            var sourceCode = GeneratePartialClass(namespace_name, class_name, props);
            context.AddSource($"{class_name}.Generated.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GeneratePartialClass(string namespace_name, string class_name, List<PropertyInfo> props)
    {
        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated/>");
        if (!string.IsNullOrWhiteSpace(namespace_name))
        {
            sb.AppendLine($"namespace {namespace_name};");
            sb.AppendLine();
        }
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();

        sb.AppendLine($"public partial class {class_name}");
        sb.AppendLine("{");

        foreach (var prop in props)
        {
            var field_name = $"_{ToCamelCase(prop.PropertyName)}";

            sb.AppendLine($"    private {prop.TypeName} {field_name};");
            sb.AppendLine();
            sb.AppendLine($"    public partial {prop.TypeName} {prop.PropertyName}");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        get => {field_name};");
            sb.AppendLine($"        set");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            if (!EqualityComparer<{prop.TypeName}>.Default.Equals({field_name}, value))");
            sb.AppendLine($"            {{");
            if (prop.PassOldValue)
                sb.AppendLine($"                var old_value = {field_name};");
            sb.AppendLine($"                {field_name} = value;");
            if (prop.PassChangedName && !prop.PassOldValue)
                sb.AppendLine($"                {prop.MethodName}(nameof({prop.PropertyName}));");
            else if (!prop.PassChangedName && prop.PassOldValue)
                sb.AppendLine($"                {prop.MethodName}(old_value);");
            else if (prop.PassChangedName && prop.PassOldValue)
                sb.AppendLine($"                {prop.MethodName}(nameof({prop.PropertyName}), old_value);");
            else
                sb.AppendLine($"                {prop.MethodName}();");
            sb.AppendLine($"            }}");
            sb.AppendLine($"        }}");
            sb.AppendLine($"    }}");
            sb.AppendLine();
        }
        sb.AppendLine("}");
        return sb.ToString().Replace("\r\n", "\n");
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name) || name.Length < 2)
            return name.ToLowerInvariant();

        if (char.IsUpper(name[0]))
            return char.ToLowerInvariant(name[0]) + name.Substring(1);

        return name;
    }
}

internal struct PropertyInfo
{
    public string TypeName { get; set; }
    public string PropertyName { get; set; }
    public string MethodName { get; set; }
    public bool PassChangedName { get; set; }
    public bool PassOldValue { get; set; }
    public string ClassName { get; set; }
    public string Namespace { get; set; }
    public string FullTypeName { get; set; }
    public bool IsPublic { get; set; }
}