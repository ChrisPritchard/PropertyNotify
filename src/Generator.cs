namespace PropertyNotify;

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var notify_attribute_source = @"
        namespace PropertyNotify;

[AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
public sealed class NotifyAttribute(string method_name = ""OnPropertyChanged"", bool pass_changed_name = false) : Attribute
{
    public string MethodName { get; } = method_name;
    public bool PassChangedName { get; } = pass_changed_name;
}
";
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("NotifyAttribute.cs", SourceText.From(notify_attribute_source, Encoding.UTF8)));

        var propertyDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName("PropertyNotify.NotifyAttribute",
                IsValidTarget,
                GetSemanticTargetForGeneration);

        var compilationAndProperties = context.CompilationProvider.Combine(propertyDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndProperties, static (spc, source) => Execute(source.Right, spc));
    }

    private static bool IsValidTarget(SyntaxNode context, CancellationToken _)
    {
        if (context is not PropertyDeclarationSyntax { AttributeLists.Count: > 0 } prop)
            return false;

        return prop.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static PropertyInfo GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        var attribute = context.Attributes.First();
        var symbol = context.TargetSymbol as IPropertySymbol;
        var method_name = "OnPropertyChanged";
        var pass_changed_name = false;

        var init_args = attribute.ConstructorArguments;
        if (init_args.Length > 0)
        {
            var arg_value = init_args[0].Value?.ToString();
            if (!string.IsNullOrEmpty(arg_value))
                method_name = arg_value;
            if (init_args.Length > 1)
                pass_changed_name = (bool)init_args[1].Value;
        }

        var containing_type = context.TargetSymbol.ContainingType;
        if (containing_type == null)
            return null;

        var containing_ns = containing_type.ContainingNamespace?.ToDisplayString();
        if (containing_ns == "<global namespace>")
            containing_ns = null;

        return new PropertyInfo
        {
            TypeName = symbol.Type.ToDisplayString(),
            PropertyName = symbol.Name,
            MethodName = method_name,
            PassChangedName = pass_changed_name,
            ClassName = containing_type.Name,
            Namespace = containing_ns,
            IsPublic = symbol.DeclaredAccessibility == Accessibility.Public,
            FullTypeName = containing_type.ToDisplayString()
        };
    }

    private static void Execute(ImmutableArray<PropertyInfo> properties, SourceProductionContext context)
    {
        if (properties.IsDefaultOrEmpty)
            return;

        var by_class = properties
            .Where(p => p != null)
            .Cast<PropertyInfo>()
            .GroupBy(p => p.FullTypeName);

        foreach (var class_props in by_class)
        {
            var class_name = class_props.First().ClassName;
            var namespace_name = class_props.First().Namespace;
            var props = class_props.ToList();

            var sourceCode = GeneratePartialClass(namespace_name, class_name, props);
            context.AddSource($"{class_name}.Generated.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private static string GeneratePartialClass(string namespace_name, string class_name, List<PropertyInfo> props)
    {
        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");

        sb.AppendLine();
        if (!string.IsNullOrWhiteSpace(namespace_name))
        {
            sb.AppendLine($"namespace {namespace_name}");
            sb.AppendLine("{");
        }
        sb.AppendLine($"    public partial class {class_name}");
        sb.AppendLine("    {");

        foreach (var prop in props)
        {
            var field_name = $"_{ToCamelCase(prop.PropertyName)}";

            sb.AppendLine($"        private {prop.TypeName} {field_name};");
            sb.AppendLine();
            sb.AppendLine($"        public partial {prop.TypeName} {prop.PropertyName}");
            sb.AppendLine("        {");
            sb.AppendLine($"            get => {field_name};");
            sb.AppendLine($"            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                if (!EqualityComparer<{prop.TypeName}>.Default.Equals({field_name}, value))");
            sb.AppendLine("                {");
            sb.AppendLine($"                    {field_name} = value;");
            sb.AppendLine($"                    {prop.MethodName}({(prop.PassChangedName ? "nameof({prop.PropertyName})" : "")});");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        if (sb.Length > 2)
            sb.Length -= 2;

        sb.AppendLine("    }");
        if (!string.IsNullOrWhiteSpace(namespace_name))
            sb.AppendLine("}");

        return sb.ToString();
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name) || name.Length < 2)
            return name.ToLowerInvariant();

        if (char.IsUpper(name[0]))
            return char.ToLowerInvariant(name[0]) + name.Substring(1);

        return name;
    }
}

internal class PropertyInfo
{
    public string TypeName { get; set; }
    public string PropertyName { get; set; }
    public string MethodName { get; set; }
    public bool PassChangedName { get; set; }
    public string ClassName { get; set; }
    public string Namespace { get; set; }
    public string FullTypeName { get; set; }
    public bool IsPublic { get; set; }
}