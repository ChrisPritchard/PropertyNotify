// PropertyNotificationGenerator.cs
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace PropertyNotify
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var propertyDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is PropertyDeclarationSyntax { AttributeLists.Count: > 0 },
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            var compilationAndProperties = context.CompilationProvider.Combine(propertyDeclarations.Collect());
            context.RegisterSourceOutput(compilationAndProperties, static (spc, source) => Execute(source.Right, spc));
        }

        private static PropertyInfo GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;
            var propertySymbol = context.SemanticModel.GetDeclaredSymbol(propertyDeclaration);
            if (propertySymbol == null)
                return null;

            foreach (var attribute in propertySymbol.GetAttributes())
            {
                if (attribute.AttributeClass?.Name == "NotifyAttribute" ||
                    attribute.AttributeClass?.Name == "Notify")
                {
                    var methodName = "OnPropertyChanged";

                    if (attribute.ConstructorArguments.Length > 0)
                    {
                        var argValue = attribute.ConstructorArguments[0].Value?.ToString();
                        if (!string.IsNullOrEmpty(argValue))
                            methodName = argValue;
                    }

                    var containingType = propertySymbol.ContainingType;
                    if (containingType == null)
                        return null;

                    return new PropertyInfo
                    {
                        TypeName = propertySymbol.Type.ToDisplayString(),
                        PropertyName = propertySymbol.Name,
                        MethodName = methodName,
                        ClassName = containingType.Name,
                        Namespace = containingType.ContainingNamespace?.ToDisplayString(),
                        IsPublic = propertySymbol.DeclaredAccessibility == Accessibility.Public,
                        FullTypeName = containingType.ToDisplayString()
                    };
                }
            }

            return null;
        }

        private static void Execute(ImmutableArray<PropertyInfo> properties, SourceProductionContext context)
        {
            if (properties.IsDefaultOrEmpty)
                return;

            var propertiesByClass = properties
                .Where(p => p != null)
                .Cast<PropertyInfo>()
                .GroupBy(p => p.FullTypeName);

            foreach (var classGroup in propertiesByClass)
            {
                var className = classGroup.First().ClassName;
                var namespaceName = classGroup.First().Namespace;
                var propertiesList = classGroup.ToList();

                var sourceCode = GeneratePartialClass(namespaceName, className, propertiesList);
                context.AddSource($"{className}.Generated.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }
        }

        private static string GeneratePartialClass(string namespaceName, string className, List<PropertyInfo> properties)
        {
            var sb = new StringBuilder();
            sb.AppendLine(@"// <auto-generated/>");
            sb.AppendLine("using System.Collections.Generic;");

            sb.AppendLine();
            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }
            sb.AppendLine($"    public partial class {className}");
            sb.AppendLine("    {");

            foreach (var prop in properties)
            {
                var fieldName = $"_{ToCamelCase(prop.PropertyName)}";

                sb.AppendLine($"        private {prop.TypeName} {fieldName};");
                sb.AppendLine();
                sb.AppendLine($"        public partial {prop.TypeName} {prop.PropertyName}");
                sb.AppendLine("        {");
                sb.AppendLine($"            get => {fieldName};");
                sb.AppendLine($"            set");
                sb.AppendLine("            {");
                sb.AppendLine($"                if (!EqualityComparer<{prop.TypeName}>.Default.Equals({fieldName}, value))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    {fieldName} = value;");
                sb.AppendLine($"                    {prop.MethodName}();");
                sb.AppendLine("                }");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            // Remove the last newline for cleaner output
            if (sb.Length > 2)
                sb.Length -= 2;

            sb.AppendLine("    }");
            if (!string.IsNullOrWhiteSpace(namespaceName))
                sb.AppendLine("}");

            return sb.ToString();
        }

        private static string ToCamelCase(string name)
        {
            if (string.IsNullOrEmpty(name) || name.Length < 2)
                return name.ToLowerInvariant();

            if (char.IsUpper(name[0]))
                return char.ToLowerInvariant(name[0]) + name.Substring(1);

            return name;
        }
    }

    internal class PropertyInfo
    {
        public string TypeName { get; set; } = string.Empty;
        public string PropertyName { get; set; } = string.Empty;
        public string MethodName { get; set; } = string.Empty;
        public string ClassName { get; set; } = string.Empty;
        public string Namespace { get; set; } = string.Empty;
        public string FullTypeName { get; set; } = string.Empty;
        public bool IsPublic { get; set; }
    }
}